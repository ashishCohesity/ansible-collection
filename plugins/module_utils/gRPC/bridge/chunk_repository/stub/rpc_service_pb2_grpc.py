# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

from bridge.chunk_repository.stub import rpc_service_pb2 as bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2

GRPC_GENERATED_VERSION = '1.64.1'
GRPC_VERSION = grpc.__version__
EXPECTED_ERROR_RELEASE = '1.65.0'
SCHEDULED_RELEASE_DATE = 'June 25, 2024'
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    warnings.warn(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + f' but the generated code in bridge/chunk_repository/stub/rpc_service_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
        + f' This warning will become an error in {EXPECTED_ERROR_RELEASE},'
        + f' scheduled for release on {SCHEDULED_RELEASE_DATE}.',
        RuntimeWarning
    )


class RpcServiceStub(object):
    """-----------------------------------------------------------------------------

    RPC service used by the chunk repository.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.RemoveChunkFile = channel.unary_unary(
                '/cohesity.bridge.chunk_repo.stub.RpcService/RemoveChunkFile',
                request_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.RemoveChunkFileArg.SerializeToString,
                response_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.RemoveChunkFileResult.FromString,
                _registered_method=True)
        self.ReadChunks = channel.unary_unary(
                '/cohesity.bridge.chunk_repo.stub.RpcService/ReadChunks',
                request_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReadChunksArg.SerializeToString,
                response_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReadChunksResult.FromString,
                _registered_method=True)
        self.PrimaryWriteChunks = channel.unary_unary(
                '/cohesity.bridge.chunk_repo.stub.RpcService/PrimaryWriteChunks',
                request_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.PrimaryWriteChunksArg.SerializeToString,
                response_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.PrimaryWriteChunksResult.FromString,
                _registered_method=True)
        self.AuxWriteChunks = channel.unary_unary(
                '/cohesity.bridge.chunk_repo.stub.RpcService/AuxWriteChunks',
                request_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.AuxWriteChunksArg.SerializeToString,
                response_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.AuxWriteChunksResult.FromString,
                _registered_method=True)
        self.FetchChunkFileInfo = channel.unary_unary(
                '/cohesity.bridge.chunk_repo.stub.RpcService/FetchChunkFileInfo',
                request_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.FetchChunkFileInfoArg.SerializeToString,
                response_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.FetchChunkFileInfoResult.FromString,
                _registered_method=True)
        self.ListChunkFiles = channel.unary_unary(
                '/cohesity.bridge.chunk_repo.stub.RpcService/ListChunkFiles',
                request_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ListChunkFilesArg.SerializeToString,
                response_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ListChunkFilesResult.FromString,
                _registered_method=True)
        self.ReplicateChunkFile = channel.unary_unary(
                '/cohesity.bridge.chunk_repo.stub.RpcService/ReplicateChunkFile',
                request_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReplicateChunkFileArg.SerializeToString,
                response_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReplicateChunkFileResult.FromString,
                _registered_method=True)
        self.ReadMorphedData = channel.unary_unary(
                '/cohesity.bridge.chunk_repo.stub.RpcService/ReadMorphedData',
                request_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReadMorphedDataArg.SerializeToString,
                response_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReadMorphedDataResult.FromString,
                _registered_method=True)
        self.AdjustDiskUsage = channel.unary_unary(
                '/cohesity.bridge.chunk_repo.stub.RpcService/AdjustDiskUsage',
                request_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.AdjustDiskUsageArg.SerializeToString,
                response_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.AdjustDiskUsageResult.FromString,
                _registered_method=True)
        self.ClearChunkFileCorruptFlag = channel.unary_unary(
                '/cohesity.bridge.chunk_repo.stub.RpcService/ClearChunkFileCorruptFlag',
                request_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ClearChunkFileCorruptFlagArg.SerializeToString,
                response_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ClearChunkFileCorruptFlagResult.FromString,
                _registered_method=True)
        self.GetChunkFileCount = channel.unary_unary(
                '/cohesity.bridge.chunk_repo.stub.RpcService/GetChunkFileCount',
                request_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.GetChunkFileCountArg.SerializeToString,
                response_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.GetChunkFileCountResult.FromString,
                _registered_method=True)
        self.WriteRaw = channel.unary_unary(
                '/cohesity.bridge.chunk_repo.stub.RpcService/WriteRaw',
                request_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.WriteRawArg.SerializeToString,
                response_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.WriteRawResult.FromString,
                _registered_method=True)
        self.TruncateChunkFile = channel.unary_unary(
                '/cohesity.bridge.chunk_repo.stub.RpcService/TruncateChunkFile',
                request_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.TruncateChunkFileArg.SerializeToString,
                response_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.TruncateChunkFileResult.FromString,
                _registered_method=True)
        self.SetChunkFileUsageHint = channel.unary_unary(
                '/cohesity.bridge.chunk_repo.stub.RpcService/SetChunkFileUsageHint',
                request_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.SetChunkFileUsageHintArg.SerializeToString,
                response_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.SetChunkFileUsageHintResult.FromString,
                _registered_method=True)
        self.ScrubChunkFile = channel.unary_unary(
                '/cohesity.bridge.chunk_repo.stub.RpcService/ScrubChunkFile',
                request_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ScrubChunkFileArg.SerializeToString,
                response_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ScrubChunkFileResult.FromString,
                _registered_method=True)


class RpcServiceServicer(object):
    """-----------------------------------------------------------------------------

    RPC service used by the chunk repository.
    """

    def RemoveChunkFile(self, request, context):
        """Remove a chunk file.

        Errors returned:
        kStale: when the intent id is stale
        kNonExistent: when the chunk file doesn't exist
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ReadChunks(self, request, context):
        """Read data for some chunks from a chunk file.

        Errors returned:
        kCorrupt: when the chunk file replica is surely corrupt.
        kStale: when the metadata sent by the caller might be stale.
        kNonExistent: when the chunk file is non-existent on corresponding disk.
        kInvalid: when the metadata sent is invalid - e.g., when the version
        in the metadata is larger than the one known by the chunk
        repository.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def PrimaryWriteChunks(self, request, context):
        """Write to a chunk file. Sent by the blob store to the primary replica.

        Errors returned:
        kStale: when the intent id is stale or when the expected metadata is
        missing
        kNonExistent: when the chunk file doesn't exist
        kOutOfSpace: when the disk on which the chunk file exists runs out of
        space.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def AuxWriteChunks(self, request, context):
        """Write to a chunk file. Sent by one replica (primary or auxiliary) in the
        chunk repository to another auxiliary replica.

        Errors returned:
        kStale: when the intent id is stale
        kNonExistent: when the chunk file doesn't exist
        kOutOfSpace: when the disk on which the chunk file exists runs out of
        space.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def FetchChunkFileInfo(self, request, context):
        """Fetch the current information about the chunk file. The information
        retrieved pertains to what's relevant to the blob store.

        Errors returned:
        kStale: when the intent id is stale
        kNonExistent: when the chunk file doesn't exist
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ListChunkFiles(self, request, context):
        """List chunk files. This is issued by Apollo to retrieve all the chunk files
        residing on a disk. In any given call, a subset of chunk files are
        retrieved.

        Errors returned:
        kInvalid: when the provided cookie is invalid.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ReplicateChunkFile(self, request, context):
        """Replicate a chunk file from one disk to another. Issued by blob store to
        the target replica. The target replica will read morphed data from the
        src replica using one or more ReadMorphedData RPCs.

        Errors returned:
        kAlreadyExists: if a replica already existed on the target disk.
        kNonExistent: if the src replica doesn't exist.
        kStale: if the intent id used is stale.
        kCorrupt: if the src replica is corrupt, or if the target became
        corrupted while we were writing to it.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ReadMorphedData(self, request, context):
        """Read morphed data. Issued by the target of a replication operation to
        the src.

        Errors returned:
        kNonExistent: if the src replica doesn't exist.
        kStale: if the expected version on the replica is stale.
        kCorrupt: if the replica is corrupt.
        kNoError: If the src replica is not corrupt and we successfully read the
        replica or if the src replica is corrupt and we force read the replica
        and identify good chunks.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def AdjustDiskUsage(self, request, context):
        """Update the disk usage due to a chunk file.

        Errors returned:
        kNonExistent: if the chunk file replica doesn't exist.
        kCorrupt: if the chunk file replica is corrupt.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ClearChunkFileCorruptFlag(self, request, context):
        """Clear the corrupt flag from the chunk file state for the requested chunk
        file id.

        Errors returned:
        kNonExistent: if the chunk file replica doesn't exist.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetChunkFileCount(self, request, context):
        """Return the number of chunk files present on a requested disk.

        Errors returned:
        kInvalid: if the requested disk doesn't exist or is not owned by the
        current node.
        kNotSupported: if the disk chunk repository WAL is kept in scribe table.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def WriteRaw(self, request, context):
        """Writes the payload zcbuf at a specified offset.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def TruncateChunkFile(self, request, context):
        """Truncates the chunk file to its real usage.

        Errors returned:
        kNonExistent: if the chunk file replica doesn't exist.
        kInvalid: if the requested disk doesn't exist or is not owned by the
        current node.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SetChunkFileUsageHint(self, request, context):
        """Sets the chunk file usage hint to help chunk repo calculating the viewbox
        and cluster usage. In some cases (e.g., bridge crash), we may end up with
        lots of chunk files without chunk file metadata. When chunk repository
        deletes those chunk files, it doesn't know how much the chunk file has
        contributed to the view box usage. As a result, the view box usage stats
        may be off by too much. This RPC is to be invoked by BlobStore every time
        it decides to delete a chunk file. ChunkRepository will persist the usage
        upon receiving such requests. Later when it deletes the chunk file, if the
        chunk file metadata is already gone, it will get the view box usage from
        this hint.

        Errors returned:
        kInvalid: if the request disk doesn't exist or is not owned by the
        current node.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ScrubChunkFile(self, request, context):
        """Scrubs the replica of a chunk file owned by this chunk repository. If
        corrupt chunk file is found healthy after scrub then corruption bit on
        chunk file replica is cleared.

        Errors returned:
        kInvalid: when the input is bad.
        kNotOwner: when current constituent doesn't have disk controller that
        owns the chunk file.
        kRetry: when disk controller for replica disk is not initialized.
        kSkipped: when corrupt chunk file scrub is skipped due to recent
        unsuccessful scrub for the same chunk file.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_RpcServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'RemoveChunkFile': grpc.unary_unary_rpc_method_handler(
                    servicer.RemoveChunkFile,
                    request_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.RemoveChunkFileArg.FromString,
                    response_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.RemoveChunkFileResult.SerializeToString,
            ),
            'ReadChunks': grpc.unary_unary_rpc_method_handler(
                    servicer.ReadChunks,
                    request_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReadChunksArg.FromString,
                    response_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReadChunksResult.SerializeToString,
            ),
            'PrimaryWriteChunks': grpc.unary_unary_rpc_method_handler(
                    servicer.PrimaryWriteChunks,
                    request_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.PrimaryWriteChunksArg.FromString,
                    response_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.PrimaryWriteChunksResult.SerializeToString,
            ),
            'AuxWriteChunks': grpc.unary_unary_rpc_method_handler(
                    servicer.AuxWriteChunks,
                    request_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.AuxWriteChunksArg.FromString,
                    response_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.AuxWriteChunksResult.SerializeToString,
            ),
            'FetchChunkFileInfo': grpc.unary_unary_rpc_method_handler(
                    servicer.FetchChunkFileInfo,
                    request_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.FetchChunkFileInfoArg.FromString,
                    response_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.FetchChunkFileInfoResult.SerializeToString,
            ),
            'ListChunkFiles': grpc.unary_unary_rpc_method_handler(
                    servicer.ListChunkFiles,
                    request_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ListChunkFilesArg.FromString,
                    response_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ListChunkFilesResult.SerializeToString,
            ),
            'ReplicateChunkFile': grpc.unary_unary_rpc_method_handler(
                    servicer.ReplicateChunkFile,
                    request_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReplicateChunkFileArg.FromString,
                    response_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReplicateChunkFileResult.SerializeToString,
            ),
            'ReadMorphedData': grpc.unary_unary_rpc_method_handler(
                    servicer.ReadMorphedData,
                    request_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReadMorphedDataArg.FromString,
                    response_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReadMorphedDataResult.SerializeToString,
            ),
            'AdjustDiskUsage': grpc.unary_unary_rpc_method_handler(
                    servicer.AdjustDiskUsage,
                    request_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.AdjustDiskUsageArg.FromString,
                    response_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.AdjustDiskUsageResult.SerializeToString,
            ),
            'ClearChunkFileCorruptFlag': grpc.unary_unary_rpc_method_handler(
                    servicer.ClearChunkFileCorruptFlag,
                    request_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ClearChunkFileCorruptFlagArg.FromString,
                    response_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ClearChunkFileCorruptFlagResult.SerializeToString,
            ),
            'GetChunkFileCount': grpc.unary_unary_rpc_method_handler(
                    servicer.GetChunkFileCount,
                    request_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.GetChunkFileCountArg.FromString,
                    response_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.GetChunkFileCountResult.SerializeToString,
            ),
            'WriteRaw': grpc.unary_unary_rpc_method_handler(
                    servicer.WriteRaw,
                    request_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.WriteRawArg.FromString,
                    response_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.WriteRawResult.SerializeToString,
            ),
            'TruncateChunkFile': grpc.unary_unary_rpc_method_handler(
                    servicer.TruncateChunkFile,
                    request_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.TruncateChunkFileArg.FromString,
                    response_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.TruncateChunkFileResult.SerializeToString,
            ),
            'SetChunkFileUsageHint': grpc.unary_unary_rpc_method_handler(
                    servicer.SetChunkFileUsageHint,
                    request_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.SetChunkFileUsageHintArg.FromString,
                    response_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.SetChunkFileUsageHintResult.SerializeToString,
            ),
            'ScrubChunkFile': grpc.unary_unary_rpc_method_handler(
                    servicer.ScrubChunkFile,
                    request_deserializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ScrubChunkFileArg.FromString,
                    response_serializer=bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ScrubChunkFileResult.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'cohesity.bridge.chunk_repo.stub.RpcService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('cohesity.bridge.chunk_repo.stub.RpcService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class RpcService(object):
    """-----------------------------------------------------------------------------

    RPC service used by the chunk repository.
    """

    @staticmethod
    def RemoveChunkFile(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cohesity.bridge.chunk_repo.stub.RpcService/RemoveChunkFile',
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.RemoveChunkFileArg.SerializeToString,
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.RemoveChunkFileResult.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ReadChunks(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cohesity.bridge.chunk_repo.stub.RpcService/ReadChunks',
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReadChunksArg.SerializeToString,
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReadChunksResult.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def PrimaryWriteChunks(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cohesity.bridge.chunk_repo.stub.RpcService/PrimaryWriteChunks',
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.PrimaryWriteChunksArg.SerializeToString,
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.PrimaryWriteChunksResult.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def AuxWriteChunks(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cohesity.bridge.chunk_repo.stub.RpcService/AuxWriteChunks',
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.AuxWriteChunksArg.SerializeToString,
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.AuxWriteChunksResult.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def FetchChunkFileInfo(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cohesity.bridge.chunk_repo.stub.RpcService/FetchChunkFileInfo',
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.FetchChunkFileInfoArg.SerializeToString,
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.FetchChunkFileInfoResult.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ListChunkFiles(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cohesity.bridge.chunk_repo.stub.RpcService/ListChunkFiles',
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ListChunkFilesArg.SerializeToString,
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ListChunkFilesResult.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ReplicateChunkFile(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cohesity.bridge.chunk_repo.stub.RpcService/ReplicateChunkFile',
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReplicateChunkFileArg.SerializeToString,
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReplicateChunkFileResult.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ReadMorphedData(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cohesity.bridge.chunk_repo.stub.RpcService/ReadMorphedData',
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReadMorphedDataArg.SerializeToString,
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ReadMorphedDataResult.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def AdjustDiskUsage(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cohesity.bridge.chunk_repo.stub.RpcService/AdjustDiskUsage',
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.AdjustDiskUsageArg.SerializeToString,
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.AdjustDiskUsageResult.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ClearChunkFileCorruptFlag(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cohesity.bridge.chunk_repo.stub.RpcService/ClearChunkFileCorruptFlag',
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ClearChunkFileCorruptFlagArg.SerializeToString,
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ClearChunkFileCorruptFlagResult.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetChunkFileCount(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cohesity.bridge.chunk_repo.stub.RpcService/GetChunkFileCount',
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.GetChunkFileCountArg.SerializeToString,
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.GetChunkFileCountResult.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def WriteRaw(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cohesity.bridge.chunk_repo.stub.RpcService/WriteRaw',
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.WriteRawArg.SerializeToString,
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.WriteRawResult.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def TruncateChunkFile(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cohesity.bridge.chunk_repo.stub.RpcService/TruncateChunkFile',
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.TruncateChunkFileArg.SerializeToString,
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.TruncateChunkFileResult.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def SetChunkFileUsageHint(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cohesity.bridge.chunk_repo.stub.RpcService/SetChunkFileUsageHint',
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.SetChunkFileUsageHintArg.SerializeToString,
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.SetChunkFileUsageHintResult.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ScrubChunkFile(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cohesity.bridge.chunk_repo.stub.RpcService/ScrubChunkFile',
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ScrubChunkFileArg.SerializeToString,
            bridge_dot_chunk__repository_dot_stub_dot_rpc__service__pb2.ScrubChunkFileResult.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
